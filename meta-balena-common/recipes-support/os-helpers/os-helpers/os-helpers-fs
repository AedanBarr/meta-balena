#!/bin/sh

# Copyright 2019 Balena Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# Filesystems related definitions for OS scripts
#


# Wait for a file to appear with loop count limit.
# Use-case example: wait for udev to create a filesystem symlink.
# Arguments:
#   1 - target path
#   2 - number of loops (each loop sleeps for 100ms)
wait4file() {
    _lpath="$1"
    _lloops="$2"

    while [ ! -e "$_lpath" ]; do
        if [ "$_lloops" -gt 0 ]; then
		sleep 0.1
		_lloops=$((_lloops-1))
        else
	    return 1
        fi
    done
    return 0
}

# Each entry needs to be in the label:fstype:kernelparameter form
filesystems_spec=" \
    resin-boot:vfat:uuid_boot \
    resin-rootA:ext4:uuid_roota \
    resin-rootB:ext4:uuid_rootb \
    resin-state:ext4:uuid_state \
    resin-data:ext4:uuid_data \
    "

# Returns the kernel parameter to which a label maps
# Argument:
#   1 - label
# Returns:
#   0 - map for the label found (prints the mapping kernel parameter to stdout)
#   1 - map for the label not found
get_fs_param() {
    [ -z "$1" ] && return 1
    for f in $filesystems_spec; do
        if [ "$(echo "$f" | cut -d':' -f1)" = "$1" ]; then
            echo "$f" | cut -d':' -f3
            return 0
        fi
    done
    return 1
}

# Returns the UUID set in cmdline for a label
# Argument:
#   1 - label
# Returns:
#   0 - uuid is set in cmdline for the label (prints the matching uuid to stdout)
#   1 - uuid is not set in cmdline for the label
get_cmdline_uuid() {
    CMDLINE=${HELPER_CMDLINE:-/proc/cmdline}
    [ -z "$1" ] && return 1
    if ! _param=$(get_fs_param "$1"); then
        return 1
    fi
    # shellcheck disable=SC2013
    for p in $(cat "$CMDLINE"); do
        opt="$(echo "$p" | cut -d'=' -f1)"
        if [ "$opt" = "$_param" ]; then
            echo "$p" | cut -d'=' -f2
            return 0
        fi
    done
    return 1
}

# Returns the cmdline matching UUID for a label.
# Argument:
#   1 - label
# Returns:
#   0
# stdout:
#   uuid  - the passed argument has a matching UUID in cmdline
#   label - the passed argument does not have a matching UUID in cmdline
get_cmdline_uuid_label() {
    [ -z "$1" ] && return 1
    if _uuid=$(get_cmdline_uuid "$1"); then
        echo "$_uuid"
    else
        echo "$1"
    fi
    return 0
}

# Returns the udev symlink path of a cmdline matching UUID for a label.
# Argument:
#  1 - label
# Returns:
#  uuid symlink udev path  - the passed aurgument has a matching UUID in cmdline
#  label symlink udev path - the passed aurgument does not have a matching UUID
#                            in cmdline
get_cmdline_uuid_label_path() {
    [ -z "$1" ] && return 1
    if _uuid=$(get_cmdline_uuid "$1"); then
        echo "/dev/disk/by-uuid/$_uuid"
    else
        echo "/dev/disk/by-label/$1"
    fi
}

# Returns the UUID/serial of a filesystem identified by label.
# When multiple filesystems have the same labels, the first one is considered.
# Arguments:
#   1 - filesystem label
get_label_uuid () {
    blkid | grep "LABEL=\"$1\"" | head -n1 | sed -n 's/.*UUID=\"\([^\"]*\)\".*/\1/p'
}

# Returns filesystem UUID based on a device node
# Arguments:
#   1 - device node
get_devnode_uuid () {
    blkid "$1" | sed -n 's/.*UUID=\"\([^\"]*\)\".*/\1/p'
}

# Check if all UUIDs are set in the cmdline
# Returns
#   0 - all UUIDs are present in cmdline
#   1 - at least one UUID is not present in cmdline
check_cmdline_uuids() {
    for spec in $filesystems_spec; do
        if ! get_cmdline_uuid "$(echo "$spec" | cut -d':' -f1)" > /dev/null 2>&1; then
            return 1
        fi
    done
    return 0
}

# Check if a uuid is part of the cmdline and if yes, return the associated label
# Returns
#   0 - the passed uuid is part of the cmdline
#   1 - the passed uuid is not part of the cmdline
check_cmdline_uuid() {
    for spec in $filesystems_spec; do
        _l="$(echo "$spec" | cut -d':' -f1)"
        _u="$(get_cmdline_uuid "$_l")"
	    if [ "$_u" = "$1" ]; then
            return 0
        fi
    done
    return 1
}
