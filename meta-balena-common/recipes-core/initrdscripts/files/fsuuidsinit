#!/bin/sh

# Copyright 2019 Balena Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# Initializes the filesystem UUIDs/serials and writes them to file
#

LABEL_WAIT_LOOPS=300 # ~ 100ms/loop * 300loops = 30000ms = 30s

# Where to store the UUIDs
store_label="resin-boot"

# shellcheck disable=SC2034
newlabel_cmd_ext4="echo y | tune2fs -U random"
# shellcheck disable=SC2034
newlabel_cmd_vfat="mlabel -s -n"

# Enable module function
fsuuidsinit_enabled() {
    # Enable if the uuids were not already generated which we test by checking
    # if a partition uuid was passed as kernel argument. This has the
    # assumption that if one partition uuid was passed, all the rest are
    # available as well.
    # shellcheck disable=SC2154
    if [ "$bootparam_flasher" = "true" ]; then
        info "Flasher detected. Avoiding filesystem UUIDS initialization."
        return 1
    fi
    # shellcheck disable=SC2154
    _arg="$(echo "$filesystems_spec" | awk '{print $1}' | cut -d':' -f3)"
    _value="$(eval echo "\$bootparam_$_arg")"
    if [ -n "$_value" ]; then
        info "UUIDs already generated so no need to initialize any new ones."
        return 1
    fi
    return 0
}

# Main module function
fsuuidsinit_run() {
    # Generate new UUIDs/serials
    if [ -z "$filesystems_spec" ]; then
        error "No filesystems spec to work on."
        return
    fi
    if [ -z "$store_label" ]; then
        error "Could not detect where to store the UUIDs."
        return
    fi
    info "Generating new UUIDs/serials for all filesystems..."
    export_uuids="# OS autogenerated file - don't manually edit it"
    for f in $filesystems_spec; do
        label="$(echo "$f" | cut -d':' -f1)"
        fstype="$(echo "$f" | cut -d':' -f2)"
        param="$(echo "$f" | cut -d':' -f3)"
        newlabel_cmd="$(eval echo "\$newlabel_cmd_$fstype")"
        if [ -z  "$newlabel_cmd" ]; then
            error "No new label command defined for $fstype."
            return
        fi
        label_path="/dev/disk/by-label/$label"
        if ! wait4file "$label_path" "$LABEL_WAIT_LOOPS"; then
            error "Timeout while waiting for $label udev label symlink."
            return
        fi

        # Filesystem type specific quirks
        case $fstype in
                vfat)
                    # mlabel doesn't work on file directly. It needs a drive to file
                    # mapping in its configuration.
                    info "Running quirks for $fstype..."
                    cat > "/etc/mtools.conf" <<EOF
drive a: file="$label_path" exclusive
EOF
                    label_path="a:"
                    ;;
                ext*)
                    # tune2fs refuses to work when the filesystem was not
                    # freshly checked.
                    info "Running quirks for $fstype..."
                    if ! e2fsck -fp "$label_path"; then
                        warn "Failed to force check filesystem on $label."
                    fi
                    ;;
                *)
        esac

        old_uuid="$(get_label_uuid "$label")"
        if ! eval "$newlabel_cmd" "$label_path"; then
            error "Failed to generate a new UUID/serial for $label."
            return
        fi
        new_uuid="$(get_label_uuid "$label")"
        export_uuids="$(printf "%s\n%s=%s" "$export_uuids" "$param" "$new_uuid")"
        info "The new filesystem UUID/serial for $label is $new_uuid (from $old_uuid)."
    done

    # Store the UUIDs
    mountpoint="/mnt/tmp"
    store_file="$mountpoint/os_fs_uuids.txt"
    store_file_tmp="$store_file.tmp"
    store_label_path="/dev/disk/by-label/$store_label"
    info "Writing new UUIDs to $store_file..."
    mkdir -p "$mountpoint"
    if ! wait4file "$store_label_path" "$LABEL_WAIT_LOOPS"; then
        error "Timeout while waiting for $store_label udev label symlink."
        return
    fi
    if ! mount "$store_label_path" "$mountpoint"; then
        error "Failed to mount $store_label filesystem."
        return
    fi
    echo "$export_uuids" > "$store_file_tmp"
    sync -f "$store_file_tmp"
    mv "$store_file_tmp" "$store_file"
    sync
    if ! umount "$mountpoint"; then
        warn "Failed to unmount $mountpoint."
    fi

    info "Done."
}
